# vim: ft=bash
_env_cmd chezmoi || return
[ -d "$(chezmoi source-path)" ] || return

# echo chezmoi state
if [ -z "$TMUX" ]; then
    _verify=$(chezmoi verify --exclude=scripts >/dev/null 2>&1 || echo "drift (inspect with 'cz state') ")
    _uncommitted=$(chezmoi git status -- --porcelain 2>/dev/null | grep -q . && echo "uncommitted " || :)
    _unpushed=$(chezmoi git log -- --branches --not --remotes --oneline 2>/dev/null | grep -q . && echo "unpushed" || :)

    [ -n "${_verify}${_uncommitted}${_unpushed}" ] && \
      printf "\033[33mchezmoi: %s%s%s\033[0m\n" "$_verify" "$_uncommitted" "$_unpushed"
    unset _verify _uncommitted _unpushed
fi

unset -f czup 2>/dev/null

cz() {
    args="$@"
    word="$1"
    shift 1
    case "$word" in
        state)
            chezmoi status --exclude=scripts; chezmoi git -- status -s
            ;;
        up)
            chezmoi update && resrc
            ;;
        ap)
            chezmoi apply && resrc
            ;;
        edit)
            chezmoi edit --apply "$@"
            ;;
        diff)
            chezmoi diff --exclude=scripts "$@"
            ;;
        save)
            printf 'Saving chezmoi changes to git...\n\n'
            chezmoi git -- diff --quiet 2>/dev/null || \
                chezmoi git add .

            chezmoi git -- diff --cached --quiet 2>/dev/null || {
                printf 'Changes:\n'
                chezmoi git -- status -s
                sleep 2.5
                printf '\n'
                chezmoi git -- commit -m "${*:-$(chezmoi git -- status -s)}" -m "$(hostname -s)"
            }
            chezmoi git -- pull --rebase && chezmoi git push
            printf 'Chezmoi saved to git\n'
            ;;
        add)
            if [ "$#" -lt 1 ]; then
                chezmoi re-add --interactive
            else
                for f in "$@"; do
                    if chezmoi source-path "$f" >/dev/null 2>&1; then
                        chezmoi re-add "$f"
                    else
                        echo "add file $f"
                        chezmoi add "$f"
                    fi
                done
            fi
            ;;
        *) chezmoi "$args"
            ;;
    esac
    unset word
}

alias sshconfig="cz edit ~/.ssh/config && resrc"

# remote local install chezmoi
cz-ssh() {
    ssh "$@" 'sh <(curl -fsLS get.chezmoi.io/lb || wget -qO- get.chezmoi.io/lb) -- init --force --apply freepaddler; rm -rf $(chezmoi source-path)'
}

_env_cmd complete && {
    _cz_completion() {
        local words="state up ap save"
        local words_path="edit diff add"
        local cur prev
        COMPREPLY=()

        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"

        # position 1 after command: suggest all keywords
        if (( COMP_CWORD == 1 )); then
            local opts="$words $words_path"
            COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
            return 0
        fi

        # if previous word is one that wants a path â†’ complete files/dirs
        for w in $words_path; do
            if [[ $prev == "$w" ]]; then
                COMPREPLY=( $(compgen -f -- "$cur") )
                return 0
            fi
        done

        # otherwise: no completion (you could fall back to files here if you want)
        return 0
    }
    complete -F _cz_completion cz
}

_env_shell zsh && {
    compdef _ssh cz-ssh=ssh
}

_env_shell bash && {
    . <(chezmoi completion bash --)
    _env_bash_clone_completion ssh cz-ssh
}
