# show shell and machine info
shell=$(printf '%s\n' "$0" | sed 's/^-//')
shell_version=""

case "$shell" in
    bash) shell_version="$BASH_VERSION" ;;
    zsh)  shell_version="$ZSH_VERSION" ;;
esac

if [ -f /etc/os-release ]; then
    . /etc/os-release
    os_name="$PRETTY_NAME $(uname -srm)"
else
    os_name="$(uname -srm)"
fi

echo "${shell}${shell_version:+ [$shell_version]} @ $os_name"
unset shell shell_version os_name

# chezmoi state
if command -v chezmoi >/dev/null 2>&1 && chezmoi source-path >/dev/null 2>&1; then
    _verify=$(chezmoi verify --exclude=scripts >/dev/null 2>&1 || echo "drift (inspect with 'czst') ")
    _uncommitted=$(chezmoi git status -- --porcelain 2>/dev/null | grep -q . && echo "uncommitted " || :)
    _unpushed=$(chezmoi git log -- --branches --not --remotes --oneline 2>/dev/null | grep -q . && echo "unpushed" || :)

    [ -n "${_verify}${_uncommitted}${_unpushed}" ] && \
      printf "\033[33mchezmoi: %s%s%s\033[0m\n" "$_verify" "$_uncommitted" "$_unpushed"
    unset _verify _uncommitted _unpushed
fi

# show existing tmux sessions on start
if [ -z "$TMUX" ] && command -v tmux >/dev/null 2>&1; then
    tmux has-session 2>/dev/null && {
        printf "\033[32mtmux sessions:\033[0m\n"
        tmux list-sessions
    }
fi

where() {
    command -v "$1"
}

# generate passwords
apg() {
    echo
    local i=0
    while [ $i -lt 20 ]; do
        openssl rand -base64 $((((i / 5) + 2) * 3))
        i=$((i + 1))
    done
}

# random hex string
rand_x() {
    # shellcheck disable=SC2002
    cat /dev/urandom | LC_CTYPE=POSIX tr -dc 'a-f0-9' | fold -w "$1" | head -n 1
}

# random alfa-numeric string
rand() {
    # shellcheck disable=SC2002
    cat /dev/urandom | LC_CTYPE=POSIX tr -dc 'A-Za-z0-9' | fold -w "$1" | head -n 1
}

# short emacs-style help
hlp() {
    local b="\033[1m"
    local r="\033[0m"
    echo -ne "${b} SHELL Quick Help${r}
\t\t\t${b}MOVING${r}
${b}C-a / C-e${r} — start/end of line\t\t${b}C-f / C-b${r} — one char fwd/bwd
${b}M-f / M-b${r} — one word fwd/bwd\t\t${b}C-l${r} - cls & leave current line
${b}C-x C-x${r} - move to the start of line and back to current position
${b}M-<space>${r} - mark position to jump instead of start of the line
\t\t\t${b}CHANGE TEXT
${b}C-d / C-h${r} - delete/backspace\t\t${b}C-x C-u${r} - undo
${b}C-t / M-t${r} - change current character/word with previous one
${b}M-u / M-l /M-c${r} - upcase/downcase/capitalize word from current position
\t\t\t${b}KILL & YANK
${b}C-k / C-u${r} - kill to line end/start\t${b}C-y${r} - yank last killed text
${b}M-d / C-w${r} - delete from position to the end/start of word
\t\t\t${b}HISTORY
${b}M-.${r} - paste last arg\t\t\t${b}M-C-y${r} 1st arg of prev command
${b}PgUp / PgDn${r} - hist rev/fwd search\t${b}C-p / C-n${r} - prev/next command
${b}C-r${r} - incremental reverse search\t${b}C-j${r} - stop search and edit
\t\t\t${b}COMPLETIONS
${b}M-/ / M-\$ / M-!${r} - complete filename/variable/command
${b}M-TAB${r} - attempt complete with previous matches
\t\t\t${b}MISC
${b}M-#${r} - comment line\t\t\t${b}C-t${r} - send SIGINFO
${b}C-c / C-z / C-d${r} - SIGINT / SIGTSTP (suspend) / EOF - soft exit
${b}C-x C-e${r} - open $EDITOR to modify command, execute upon exit
\t\t\t${b}SPECIAL VARS
${b}\$?${r} - exit status of last command\t${b}%% / %n${r} - last/n job pid
${b}\$!${r} - last backgroud command pid\t\t${b}\$\$${r} - current shell pid
${b}!!${r} - previous command line\t\t${b}!:0${r} - name of prev command
${b}!:1 / !:-1 / !:*${r} - 1st(2nd..)/last/all params of prev command
"
    #${b}M-< / M->${r} - move to hist first/last line
    #${b}C-r / C-s${r} - incremental rev/fwd search
}


## _dotfiles helpers

# add function or variable to unset list
_dotfiles_unset_add() {
   DOTFILES_UNSET="$DOTFILES_UNSET $*"
}

# should be called at the very end .profile
_dotfiles_cleanup() {
    _dotfiles_unset_add _dotfiles_unset_add
    _dotfiles_unset_add _dotfiles_cleanup
    for u in $DOTFILES_UNSET; do
        #echo "unsetting $u"
        unset "$u";
    done
    unset DOTFILES_UNSET u
}

# check command exists
_dotfiles_unset_add _dotfiles_cmd
_dotfiles_cmd() {
    command -v "$1" >/dev/null 2>&1
}

# add path to the END
_dotfiles_unset_add _dotfiles_path_append
_dotfiles_path_append() {
    case ":$PATH:" in
        *":$1:"*) ;;
        *) PATH=${PATH:+$PATH:}$1 ;;
    esac
}

# add path to the BEGINNING
_dotfiles_unset_add _dotfiles_path_prepend
_dotfiles_path_prepend() {
    # remove the existing entry if it exists
    PATH=$(echo ":$PATH:" | sed -e "s|:$1:|:|g" -e 's|^:||;s|:$||')
    PATH=$1${PATH:+:$PATH}
}

_dotfiles_unset_add _dotfiles_os_is
_dotfiles_os_is() {
    [ "$DOTFILES_OS" = "$1" ]
}

_dotfiles_unset_add _dotfiles_source
_dotfiles_source() {
    for f in "$@"; do
        [ -f "$f" ] && . "$f"
    done
    unset f
}
