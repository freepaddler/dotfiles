# check if shell is interactive
set +x
if [[ $- != *i* ]]; then
    return
fi

echo bash "$BASH_VERSION"
KERNEL=$(uname -s)
is_mac() {
    [ "$KERNEL" = "Darwin" ]
}
is_linux() {
    [ "$KERNEL" = "Linux" ]
}
is_freebsd() {
    [ "$KERNEL" = "FreeBSD" ]
}

### COMMON ENV VARS
export BLOCKSIZE="K"
export EDITOR="vi"
export VISUAL="vi"
export LSCOLORS="gxfxcxdxbxegedabagacad"
export LS_COLORS="di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43"
# to disable alternate screen -XF
export LESS="-iRJ -P?f%f .?m(%i/%m) .?ltLn %lt-%lb?L/%L. .?dbPg %db?s/%D. .?e(END) ?x\:n -> %x.:?Pb[%Pb\%]..%t"
export PAGER="less"
# remove duplicates from histiry
export HISTCONTROL="ignoredups"
export HISTSIZE=1000
export HISTFILESIZE=10000
export HISTTIMEFORMAT="%h %d %H:%M:%S "
# append session history to history file upon exit
shopt -s histappend
# save multiline commands as multiline but in one history entry
shopt -s cmdhist
shopt -s lithist
# auto edit mistakes in path
shopt -s cdspell
# show command from history instead running !! !34
shopt -s histverify
# do not accept output replacing existing file >| to force
set -o noclobber
# return error if any of the commands in pipe chain exit > 0
#set -o pipefail

# locales
export LANG=ru_RU.UTF-8
export LC_TYPE=ru_RU.UTF-8
export LC_COLLATE=ru_RU.UTF-8
export LC_MESSAGES=POSIX
export LC_NUMERIC=POSIX
export LC_TIME=POSIX
export LC_ALL=

### PATH
umask 0002
path_append() {
    case ":$PATH:" in
        *:"$1":*) ;;
        *) PATH=${PATH:+$PATH:}$1 ;;
    esac
}
path_prepend() {
    case ":$PATH:" in
        *:"$1":*) ;;
        *) PATH=$1:${PATH:+$PATH} ;;
    esac
}

### SHELL DECORATIONS
export PS1="\n\[\$([ \$(id -u) -eq 0 ] && printf '\033[1;31m' || printf '\033[1;32m')\]\u\[\033[0m\]@\[\033[0;33m\]\H \[\033[0;36m\]\w\n\[\033[1;0m\]\\$\[\033[0m\] "
export PS2="\[\033[1;33m\]-> \[\033[0m\]"

set_window_title() {
    printf "\033]2;%s\007" "$1"
}

if [ "$TERM_PROGRAM" == "Apple_Terminal" ]; then
    PROMPT_COMMAND="set_window_title${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
else
    TILDA="~"
    PROMPT_COMMAND='printf "\033]0;%s@%s %s\007" "$USER" "$HOSTNAME" "${PWD/$HOME/$TILDA}"'
fi

## HOMEBREW
if is_mac && [ -x /opt/homebrew/bin/brew ]; then
    path_append "/opt/homebrew/bin:/opt/homebrew/sbin"
    export HOMEBREW_PREFIX="/opt/homebrew"
    export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
    export HOMEBREW_REPOSITORY="/opt/homebrew"
    export INFOPATH=$INFOPATH:/opt/homebrew/share/info
    export MANPATH=$MANPATH:/opt/homebrew/share/man
    alias brew-requested="brew leaves -r && echo && brew list --cask -1"
    brew-usage() {
        brew list --formula | xargs -n1 -P8 -I {} \
            sh -c "brew info {} | egrep '[0-9]* files, ' | sed 's/^.*[0-9]* files, \(.*\)).*$/{} \1/'" |
            sort -h -r -k2 - | column -t
    }
fi

### AUTOCOMPLETION
# try load completion script if not loaded yet
completion_script_lookup="
    /usr/share/bash-completion
    /usr/local/share/bash-completion
    ${HOMEBREW_PREFIX:+$HOMEBREW_PREFIX/etc/profile.d/}
    /opt/local/etc/profile.d
"
for bcsh in $completion_script_lookup; do
    [ "$(type -t _completion_loader)" = "function" ] && break
    [ -r "$bcsh/bash_completion.sh" ] && source "$bcsh/bash_completion.sh"
done
unset completion_script_lookup
# check if command has completion
has_completion() {
    # completion exists
    complete -p "$1" &> /dev/null && return 0
    # no loader -> no completion
    [ "$(type -t _completion_loader)" = "function" ] || return 1
    # try load completion
    _completion_loader "$1"
    # _minimal default to no completion
    [[ $(complete -p "$1" 2> /dev/null) = *_minimal* ]] || return 0
    # delete _minimal completion -> no completion
    complete -r "$1"
    return 1
}

# if no bash-completion, let's make out life a little bit easier
has_completion man || complete -cf man
has_completion nohup || complete -c -o bashdefault -o default nohup
has_completion su || complete -c -o bashdefault -o default su

### PROGRAMS SETUP
# ssh
if has_completion ssh; then
    complete -F _ssh sshexit sshm ssh-copy-id ssh-cp-env ssh-del-knownhost ssh-run ssh-chezmoi
else
    complete -fW \
        "$({ grep -iE '^(host|hostname)' ~/.ssh/config | cut -d' ' -f2; cut -d' ' -f1 ~/.ssh/known_hosts1 2> /dev/null; } | grep -v '\*' | sort | uniq)" \
        ssh scp sftp sshexit sshm ssh-copy-id ssh-cp-env ssh-del-knownhost ssh-run ssh-chezmoi
fi
alias sshconfig="vi ~/.ssh/config && resrc"
alias sshexit="ssh -O exit"
alias sshm="ssh -M"

# doas
if which doas &> /dev/null; then
    has_completion doas || complete -c -o bashdefault -o default doas
    alias doas="doas "
fi

# sudo
if which sudo &> /dev/null; then
    has_completion sudo || complete -c -o bashdefault -o default sudo
    alias sudo="sudo "
fi

# mysql ldap auth
export LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN=1

# go
if which go &> /dev/null; then
    path_append "$(go env GOPATH)/bin"
    if type gocomplete &> /dev/null; then
        complete -C "$(type -p gocomplete)" go
    fi
    if which godoc &> /dev/null; then
        godocs() {
            killall godoc &> /dev/null
            GO111MODULE=off godoc -index &> /dev/null &
            disown $!
        }
    fi
fi

# docker
if which docker &> /dev/null; then
    has_completion docker || complete -W "$(docker ps -a --format '{{.Names}}')" docker
fi

### ALIASES
alias root="su -m root"

is_linux && alias ls="ls --color=auto" || alias ls="ls -G"
alias l="ls -F"
alias ll="ls -lFh"
alias la="ls -laFh"
alias li="ls -laFhi"
is_freebsd && alias le="ls -laFohi"
is_mac && alias le="ls -laFOhie@";

alias rm="rm -iv"
alias rmrf="rm -frv"
alias cp="cp -iv"
alias cpr="cp -iRv"
alias mv="mv -iv"

alias du="du -h"
alias df="df -h"

alias j="jobs -l"
alias h="history 25"
alias p="ps uw"
is_linux && alias p="ps fuw"

alias grep="grep --color"
which igrep &> /dev/null || alias igrep="grep -i"
alias fgrep="fgrep --color"
alias egrep="egrep --color"

alias resrc="source ~/.bashrc"
alias bashrc="vi ~/.bashrc && resrc"
alias hosts="vi /etc/hosts"

which sreen &> /dev/null && alias sc="screen -U"
which vim &> /dev/null && alias vi="vim -X"
alias vimrc="vi ~/.vimrc"

which glow &> /dev/null && alias mdless="glow -p"

if which sreen &> /dev/null; then
    alias ansible-roledir="mkdir -p {defaults,files,templates,handlers,tasks} && touch {defaults,handlers,tasks}/main.yml"
    alias ansible-hostvars='ansible -m debug -a "var=hostvars[inventory_hostname]"'
fi

if which iptables &> /dev/null; then
    alias iptl="iptables --line-numbers -vnL "
    alias ipt="iptables "
fi

# git
alias gs="git status"
alias ga="git add ."
alias gp="git push"
alias gca="git commit -a -m"
alias gcm="git commit -m"
alias gi="git info"
alias gl="git logall"
alias gb="git branches"
alias glb="git logbr"
alias gu="gut pull"

### +BY OS
if is_mac; then
    export COPYFILE_DISABLE=true
    # remove macOS zsh warning
    export BASH_SILENCE_DEPRECATION_WARNING=1
    # python path
    for ver in $(ls -r ~/Library/Python/); do
        path_append ~/Library/Python/"$ver"/bin
    done
    # ssh-keygen override
    complete -f ssh-keygen
    # logout other macos user
    macos_logout() {
        sudo launchctl bootout "user/$(id -u "$1")"
    }
    [ -d "$HOME/Documents/Dev/shell/" ] && path_append ~/dev/shell
fi

### PATH EXPORT
path_append ~/.local/bin
export PATH

### UNSET global func
unset is_mac
unset is_linux
unset is_freebsd
unset path_append
unset path_prepend
unset has_completion

### import functions
 [ -f "$HOME/.bash_functions" ] && source "$HOME/.bash_functions"
