# check if shell is interactive
set +x
if [[ $- != *i* ]]; then
    return
fi

echo bash $BASH_VERSION

### COMMON ENV VARS
export BLOCKSIZE="K"
export EDITOR="vi"
export VISUAL="vi"
export LSCOLORS="gxfxcxdxbxegedabagacad"
# to disable alternate screen -XF
export LESS="-iRJ -P?f%f .?m(%i/%m) .?ltLn %lt-%lb?L/%L. .?dbPg %db?s/%D. .?e(END) ?x\:n -> %x.:?Pb[%Pb\%]..%t"
export PAGER="less"
# remove duplicates from histiry
export HISTCONTROL="ignoredups"
export HISTSIZE=1000
export HISTFILESIZE=10000
export HISTTIMEFORMAT="%h %d %H:%M:%S "
# append session history to history file upon exit
shopt -s histappend
# save multiline commands as multiline but in one history entry
shopt -s cmdhist
shopt -s lithist
# auto edit mistakes in path
shopt -s cdspell
# show command from history instead running !! !34
shopt -s histverify
# do not accept output replacing existing file >| to force
set -o noclobber
# return error if any of the commands in pipe chain exit > 0
#set -o pipefail

# locales
export LANG=ru_RU.UTF-8
export LC_TYPE=ru_RU.UTF-8
export LC_COLLATE=ru_RU.UTF-8
export LC_MESSAGES=C
export LC_NUMERIC=C
export LC_TIME=C
export LC_ALL=

### PATH
umask 0002
path_append() {
    case ":$PATH:" in
        *:"$1":*) ;;

        *)
            PATH=${PATH:+$PATH:}$1
            ;;
    esac
}
path_prepend() {
    case ":$PATH:" in
        *:"$1":*) ;;

        *)
            PATH=$1:${PATH:+$PATH}
            ;;
    esac
}

### SHELL DECORATIONS
export PS1="\n\[\$([ \$(id -u) -eq 0 ] && printf '\033[1;31m' || printf '\033[1;32m')\]\u\[\033[0m\]@\[\033[0;33m\]\H \[\033[0;36m\]\w\n\[\033[1;0m\]\\$\[\033[0m\] "
export PS2="\[\033[1;33m\]-> \[\033[0m\]"

set_window_title() {
    printf "\033]2;%s\007" "$1"
}

if [ "$TERM_PROGRAM" == "Apple_Terminal" ]; then
    PROMPT_COMMAND="set_window_title${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
else
    TILDA="~"
    PROMPT_COMMAND='printf "\033]0;%s@%s %s\007" "$USER" "$HOSTNAME" "${PWD/$HOME/$TILDA}"'
fi

## HOMEBREW
if [ -x /opt/homebrew/bin/brew ]; then
    path_append "/opt/homebrew/bin:/opt/homebrew/sbin"
    export HOMEBREW_PREFIX="/opt/homebrew"
    export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
    export HOMEBREW_REPOSITORY="/opt/homebrew"
    export INFOPATH=$INFOPATH:/opt/homebrew/share/info
    export MANPATH=$MANPATH:/opt/homebrew/share/man
    alias brew-requested="brew leaves -r && echo && brew list --cask -1"
    brew-usage (){
        brew list --formula | xargs -n1 -P8 -I {} \
        sh -c "brew info {} | egrep '[0-9]* files, ' | sed 's/^.*[0-9]* files, \(.*\)).*$/{} \1/'" | \
        sort -h -r -k2 - | column -t
    }
fi

### AUTOCOMPLETION
# try load completion script if not loaded yet
completion_script_lookup="
    /etc/profile.d
    /usr/local/share/bash-completion
    /opt/local/etc/profile.d
    "$HOMEBREW_PREFIX/etc/profile.d"
"
for bcsh in $completion_script_lookup; do
    [ "$(type -t _completion_loader)" = "function" ] && break
    [ -r "$bcsh/bash_completion.sh" ] && source "$bcsh/bash_completion.sh"
done
# try load custom completions
completions_lookup="
    /Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash
    /Applications/Docker.app/Contents/Resources/etc/docker-compose.bash-completion
    /Applications/Docker.app/Contents/Resources/etc/docker.bash-completion
    /opt/vagrant/embedded/gems/gems/vagrant-*/contrib/bash/completion.sh
    $HOME/.bash_completion.d/*
"
for f in $completions_lookup; do
    [ -r "$f" ] && source "$f"
done
unset completion_script_lookup
unset completions_lookup
# check if command has completion
has_completion() {
    # completion exists
    complete -p "$1" &> /dev/null && return 0
    # no loader -> no completion
    [ "$(type -t _completion_loader)" = "function" ] || return 1
    # try load completion
    _completion_loader "$1"
    # _minimal default to no completion
    [[ $(complete -p "$1" 2> /dev/null) = *_minimal* ]] || return 0
    # delete _minimal completion -> no completion
    complete -r "$1"
    return 1
}

# if no bash-completion, let's make out life a little bit easier
has_completion man || complete -cf man
has_completion nohup || complete -c -o bashdefault -o default nohup
has_completion su || complete -c -o bashdefault -o default su

### PROGRAMS SETUP
# ssh
if has_completion ssh; then
    complete -F _ssh ssh-cp-env.sh ssh-run.sh ssh-del-knownhost.sh sshexit sshm
else
    [ -f ~/.ssh/config ] && complete -fW "$(grep -iE '^(host|hostname) ' ~/.ssh/config | awk '{print $2}')" ssh ssh-copy-id sftp scp ssh-cp-env.sh ssh-run.sh ssh-del-knownhost.sh sshexit sshm
fi
alias sshconfig="vi ~/.ssh/config && resrc"
alias sshexit="ssh -O exit"
alias sshm="ssh -M"

# doas
if which doas &> /dev/null; then
    has_completion doas || complete -c -o bashdefault -o default doas
    alias doas="doas "
fi

# sudo
if which sudo &> /dev/null; then
    has_completion sudo || complete -c -o bashdefault -o default sudo
    alias sudo="sudo "
fi

# mysql ldap auth
export LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN=1

# go
if which go &> /dev/null; then
    path_append "$(go env GOPATH)/bin"
    if type gocomplete &> /dev/null; then
        complete -C "$(type -p gocomplete)" go
    fi
    if which godoc &> /dev/null; then
        godocs() {
            killall godoc &> /dev/null
            GO111MODULE=off godoc -index &> /dev/null &
            disown $!
        }
    fi
fi

# docker
if which docker &> /dev/null; then
    has_completion docker || complete -W "$(docker ps -a --format '{{.Names}}')" docker
fi


### ALIASES
alias root="su -m root"
alias l="ls -FG"
alias la="ls -laFGh"
alias ll="ls -lFGh"
alias li="ls -laFoGhi"
alias rm="rm -iv"
alias rmrf="rm -frv"
alias cp="cp -iv"
alias cpr="cp -iRv"
alias mv="mv -iv"
alias du="du -h"
alias df="df -h"
alias j="jobs -l"
alias h="history 25"

alias grep="grep --color"
which igrep &> /dev/null || alias igrep="grep -i"
alias fgrep="fgrep --color"

alias resrc="source ~/.bashrc"
alias bashrc="vi ~/.bashrc && resrc"
alias vihosts="vi /etc/hosts"

which sreen &> /dev/null && alias sc="screen -U"
which vim &> /dev/null && alias vi="vim -X"
alias vimrc="vi ~/.vimrc"

which glow &> /dev/null && alias mdless="glow -p"
which ansible &> /dev/null && alias ansible-roledir="mkdir -p {defaults,files,templates,handlers,tasks} && touch {defaults,handlers,tasks}/main.yml"

if which iptables &> /dev/null; then
    alias iptl="iptables --line-numbers -vnL "
    alias ipt="iptables "
fi

### +BY OS
KERNEL=$(uname -s)
case "$KERNEL" in
    Linux) # GNU/Linux
        alias ls="ls --color=auto"
        alias l="ls -F"
        alias la="ls -laFh"
        alias ll="ls -lFh"
        alias li="ls -laFhi"
        export LS_COLORS="di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43"
        ;;
    Darwin) # MacOs
        alias li="ls -laFOGhi"
        alias le="ls -laFGhe"
        export COPYFILE_DISABLE=true
        # remove macOS zsh warning
        export BASH_SILENCE_DEPRECATION_WARNING=1
        # python path
        for ver in $(ls -r ~/Library/Python/); do
            path_append ~/Library/Python/"$ver"/bin
        done
        # ssh-keygen override
        complete -f ssh-keygen
        # logout other macos user
        macos_logout() {
            sudo launchctl bootout "user/$(id -u "$1")"
        }
        [ -d "$HOME/Documents/Dev/shell/" ] && path_append ~/Documents/Dev/shell
        ;;
esac

### PATH EXPORT
export PATH

### UNSET global func
unset path_append
unset path_prepend
unset has_completion

apg() {
    # generate passwords
    echo
    i=0
    while [ $i -lt 20 ]; do
        openssl rand -base64 $((((i / 5) + 2) * 3))
        i=$((i + 1))
    done
}

hlp() {
    # short emacs-style help
    local b="\033[1m"
    local r="\033[0m"
    echo -ne "${b} SHELL Quick Help${r}
\t\t\t${b}MOVING${r}
${b}C-a / C-e${r} — start/end of line\t\t${b}C-f / C-b${r} — one char fwd/bwd
${b}M-f / M-b${r} — one word fwd/bwd\t\t${b}C-l${r} - cls & leave current line
${b}C-x C-x${r} - move to the start of line and back to current position
${b}M-<space>${r} - mark position to jump instead of start of the line
\t\t\t${b}CHANGE TEXT
${b}C-d / C-h${r} - delete/backspace\t\t${b}C-x C-u${r} - undo
${b}C-t / M-t${r} - change current character/word with previous one
${b}M-u / M-l /M-c${r} - upcase/downcase/capitalize word from current position
\t\t\t${b}KILL & YANK
${b}C-k / C-u${r} - kill to line end/start\t${b}C-y${r} - yank last killed text
${b}M-d / C-w${r} - delete from position to the end/start of word
\t\t\t${b}HISTORY
${b}M-.${r} - paste last arg\t\t\t${b}M-C-y${r} 1st arg of prev command
${b}PgUp / PgDn${r} - hist rev/fwd search\t${b}C-p / C-n${r} - prev/next command
${b}C-r${r} - incremental reverse search\t${b}C-j${r} - stop search and edit
\t\t\t${b}COMPLETIONS
${b}M-/ / M-\$ / M-!${r} - complete filename/variable/command
${b}M-TAB${r} - attempt complete with previous matches
\t\t\t${b}MISC
${b}M-#${r} - comment line\t\t\t${b}C-t${r} - send SIGINFO
${b}C-c / C-z / C-d${r} - SIGINT / SIGTSTP (suspend) / EOF - soft exit
${b}C-x C-e${r} - open $EDITOR to modify command, execute upon exit
\t\t\t${b}SPECIAL VARS
${b}\$?${r} - exit status of last command\t${b}%% / %n${r} - last/n job pid
${b}\$!${r} - last backgroud command pid\t\t${b}\$\$${r} - current shell pid
${b}!!${r} - previous command line\t\t${b}!:0${r} - name of prev command
${b}!:1 / !:-1 / !:*${r} - 1st(2nd..)/last/all params of prev command
"
    #${b}M-< / M->${r} - move to hist first/last line
    #${b}C-r / C-s${r} - incremental rev/fwd search
}
